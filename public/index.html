<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>MMM - Congreso Centroamericano 2026 - Comparador de Ofertas de Vuelos - Copa Airlines (90 Combinaciones)</title>
    <!-- Bootstrap 5 CSS CDN -->
    <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.3/dist/css/bootstrap.min.css" rel="stylesheet" integrity="sha384-QWTKZyjpPEjISv5WaRU9OFeRpok6YctnYmDr5pNlyT2bRjXh0JMhjY6hW+ALEwIH" crossorigin="anonymous">
    <!-- Bootstrap Icons CDN -->
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap-icons@1.11.3/font/bootstrap-icons.css">
    <style>
        body {
            background-color: #f8f9fa;
            color: #333;
        }
        .container {
            max-width: 1200px;
            margin: 0 auto;
        }
        .header-title {
            color: #0056b3;
            font-weight: bold;
            text-shadow: 1px 1px 2px rgba(0,0,0,0.1);
            text-align: center;
            margin-bottom: 30px;
            padding: 0 15px;
        }
        .btn-primary {
            background-color: #0056b3;
            border-color: #0056b3;
            font-weight: bold;
            font-size: 1.2rem;
            padding: 12px 20px;
            box-shadow: 0 4px 6px rgba(0,0,0,0.2);
            transition: all 0.3s ease;
        }
        .btn-primary:hover {
            background-color: #007bff;
            border-color: #007bff;
            transform: translateY(-2px);
        }
        .btn-primary:disabled {
            background-color: #6c757d;
            border-color: #6c757d;
            cursor: not-allowed;
        }
        .loading-progress {
            display: none;
            margin: 20px auto;
            max-width: 600px;
            text-align: center;
        }
        .progress {
            height: 1.5rem;
            background-color: #e9ecef;
            border-radius: 0.375rem;
        }
        .progress-bar {
            background-color: #0056b3 !important;
            transition: width 0.6s ease;
        }
        .error-alert {
            display: none;
            margin: 20px auto;
            max-width: 600px;
            text-align: center;
        }
        .cheapest-card {
            background-color: #d4edda !important;
            border-left: 5px solid #28a745 !important;
            margin: 15px auto;
            max-width: 700px;
        }
        .global-cheapest-card {
            background: white !important;
            border: 1px solid #e0e0e0 !important;
            border-radius: 12px !important;
            margin: 20px auto;
            max-width: 100%;
            box-shadow: 0 2px 8px rgba(0,0,0,0.1);
            padding: 0px;
            transition: box-shadow 0.3s ease;
        }
        .global-cheapest-card:hover {
            box-shadow: 0 4px 16px rgba(0,0,0,0.15);
        }
        .global-cheapest-card .global-title {
            color: #1976d2;
            font-size: 1.4rem;
            font-weight: 600;
            margin-bottom: 15px;
        }
        .global-cheapest-card .global-city {
            color: #333;
            font-size: 1.1rem;
            font-weight: 500;
            margin-bottom: 8px;
        }
        .global-cheapest-card .global-dates {
            color: #666;
            font-size: 0.95rem;
            margin-bottom: 15px;
        }
        .global-cheapest-card .global-price {
            color: #1976d2;
            font-size: 2rem;
            font-weight: bold;
            margin-bottom: 20px;
        }
        .global-cheapest-card .pre-formatted {
            color: #333 !important;
            background: #f8f9fa !important;
            border: 1px solid #a3a3a3;
            border-radius: 8px;
            padding: 12px 15px;
            margin: 15px 0;
            font-size: 0.85rem;
            line-height: 1.4;
            max-width: 500px;
            display: inline-block;
            text-align: left;
            white-space: pre-line;
        }
        .offer-image {
            max-width: 100%;
            width: 100%;
            max-height: 300px;
            margin: 10px auto;
            border: 1px solid #b1b1b1;
            border-radius: 12px;
            box-shadow: 0 4px 12px rgba(0,0,0,0.1);
            transition: transform 0.3s ease, box-shadow 0.3s ease;
            display: block;
            object-fit: contain;
        }
        .offer-image:hover {
            transform: translateY(-3px);
            box-shadow: 0 8px 20px rgba(0,0,0,0.15);
        }
        .offer-image-container {
            background: white;
            border-radius: 12px;
            padding: 0px;
            margin-top: 20px;
            box-shadow: 0 2px 8px rgba(0,0,0,0.1);
            border: 1px solid #e3f2fd;
            position: relative;
        }
        .offer-image-container h6 {
            color: #1976d2 !important;
            margin-bottom: 15px;
            font-weight: 600;
        }
        .global-offer-container {
            background: transparent;
            padding: 25px 0;
            margin: 20px 0;
            display: block !important;
        }
        .right-offer-column {
            display: flex;
            flex-direction: column;
            align-items: flex-end;
            justify-content: flex-start;
            min-width: 500px;
            max-width: 800px;
            width: 100%;
            margin: 0 auto;
            padding: 20px 20px 20px 20px;
            background: #fff;
            border-radius: 12px;
            box-shadow: 0 2px 8px rgba(0,0,0,0.07);
        }
        .right-offer-column .price {
            font-size: 2.5rem;
            color: #0056b3;
            font-weight: bold;
            margin-bottom: 8px;
        }
        .right-offer-column .class {
            font-size: 1.1rem;
            color: #666;
            margin-bottom: 12px;
        }
        .right-offer-column .select-btn {
            width: 100%;
            margin-bottom: 8px;
        }
        .right-offer-column .details-link {
            color: #1976d2;
            font-size: 1rem;
            text-decoration: underline;
            cursor: pointer;
            margin-bottom: 4px;
        }
        @media (max-width: 900px) {
            .right-offer-column {
                min-width: 180px;
                max-width: 100%;
                width: 100%;
                padding: 10px 5px;
            }
            .right-offer-column .price {
                font-size: 1.5rem;
            }
        }
        .pre-formatted {
            white-space: pre-wrap;
            font-family: 'Courier New', monospace;
            line-height: 1.4;
        }
        
        /* Estilos para pesta√±as de fechas */
        .date-tabs {
            margin: 20px 0;
        }
        
        /* Estilos para tarjetas de estad√≠sticas */
        .summary-stats {
            background: #f8f9fa;
            padding: 30px 20px;
            border-radius: 20px;
            margin: 30px 0;
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.1);
        }
        
        .stat-card {
            background: linear-gradient(135deg, #0056b3, #007bff);
            color: white;
            padding: 25px 20px;
            border-radius: 15px;
            text-align: center;
            box-shadow: 0 8px 25px rgba(0, 86, 179, 0.3);
            transition: all 0.3s ease;
            margin-bottom: 20px;
            border: none;
        }
        
        .stat-card:hover {
            transform: translateY(-5px);
            box-shadow: 0 12px 35px rgba(0, 86, 179, 0.4);
        }
        
        .stat-card h5 {
            font-size: 2.5rem;
            font-weight: bold;
            margin-bottom: 10px;
            color: #ffffff;
            text-shadow: 0 2px 4px rgba(0, 0, 0, 0.3);
        }
        
        .stat-card p {
            font-size: 1.1rem;
            margin-bottom: 0;
            color: #f8f9fa;
            font-weight: 500;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }
        
        @media (max-width: 768px) {
            .summary-stats {
                padding: 20px 15px;
                margin: 20px 0;
            }
            
            .stat-card {
                padding: 20px 15px;
                margin-bottom: 15px;
            }
            
            .stat-card h5 {
                font-size: 2rem;
            }
            
            .stat-card p {
                font-size: 1rem;
            }
        }
        
        .date-tab {
            display: inline-block;
            padding: 10px 15px;
            margin: 5px;
            background: #f8f9fa;
            border: 2px solid #dee2e6;
            border-radius: 8px;
            cursor: pointer;
            transition: all 0.3s ease;
            font-weight: bold;
        }
        
        .date-tab.active {
            background: #0056b3;
            color: white;
            border-color: #0056b3;
        }
        
        .date-tab:hover {
            background: #e9ecef;
            border-color: #adb5bd;
        }
        
        .date-tab.active:hover {
            background: #004494;
        }
        
        .date-content {
            display: none;
        }
        
        .date-content.active {
            display: block;
        }
        
        .city-group {
            margin-bottom: 30px;
            border: 1px solid #dee2e6;
            border-radius: 10px;
            padding: 20px;
            background: white;
        }
        
        .city-group h4 {
            color: #0056b3;
            margin-bottom: 15px;
            border-bottom: 2px solid #0056b3;
            padding-bottom: 5px;
        }
        
        .stopover-group {
            display: flex;
            gap: 15px;
            flex-wrap: wrap;
        }
        
        .stopover-card {
            flex: 1;
            min-width: 300px;
            border: 1px solid #dee2e6;
            border-radius: 8px;
            padding: 15px;
            background: #f8f9fa;
        }
        
        .stopover-card.has-offer {
            border-color: #28a745;
            background: #d4edda;
        }
        
        .stopover-card.has-error {
            border-color: #dc3545;
            background: #f8d7da;
        }
        
        .summary-stats {
            background: #e9ecef;
            padding: 15px;
            border-radius: 8px;
            margin-bottom: 20px;
        }
        
        @media (max-width: 768px) {
            .stopover-group {
                flex-direction: column;
            }
            
            .stopover-card {
                min-width: 100%;
            }
            
            .date-tab {
                display: block;
                margin: 2px 0;
                text-align: center;
            }
        }
        @media (max-width: 768px) {
            .container {
                padding: 10px;
            }
            .btn-primary {
                font-size: 1rem;
                padding: 10px 15px;
            }
            .cheapest-card, .global-cheapest-card {
                font-size: 0.9em;
                margin: 0px 0px;
            }
            .offer-image {
                max-width: 100%;
            }
            .header-title {
                font-size: 1.5rem;
                margin-bottom: 20px;
            }
        }
        
        /* Estilos para las nuevas tarjetas de ofertas */
        .offer-card {
            transition: transform 0.2s ease, box-shadow 0.2s ease;
        }
        
        .offer-card:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 12px rgba(0,0,0,0.1);
        }
        
        .offer-rank .badge {
            font-size: 1rem;
            padding: 8px 12px;
        }
        
        .date-info {
            font-size: 0.9rem;
        }
        
        .route-info {
            font-size: 0.85rem;
            overflow: visible;
            word-wrap: break-word;
            white-space: normal;
        }
        
        .route-info small {
            display: block;
            line-height: 1.3;
            white-space: normal;
            word-break: break-word;
        }
        
        .offer-card .card {
            min-height: 140px;
        }
        
        .offer-card .card-body {
            padding: 1rem;
        }
        
        .offer-card .row {
            align-items: flex-start !important;
        }
        
        .price-info h5 {
            font-weight: bold;
            font-size: 1.4rem;
        }
        
        /* Filtros responsivos para m√≥viles */
        .filter-container {
            position: sticky;
            top: 20px;
            z-index: 100;
            background: white;
            padding: 15px 0;
            border-bottom: 2px solid #f8f9fa;
            margin-bottom: 20px;
        }
        
        /* Mejora para desktop: evitar contenedor demasiado ancho */
        @media (min-width: 1025px) {
            .filter-container {
                max-width: 1400px;
                margin: 0 auto 20px auto;
                padding: 20px;
            }
        }
        
        .btn-group {
            display: flex;
            flex-wrap: wrap;
            gap: 8px;
            justify-content: center;
            align-items: center;
        }
        
        .btn-group .btn {
            flex: none;
            min-width: 180px;
            max-width: 220px;
            min-height: 44px; /* M√≠nimo recomendado para t√°ctil */
            padding: 12px 16px;
            border-radius: 25px !important;
            font-size: 0.9rem;
            font-weight: 600;
            transition: all 0.3s ease;
            border: 2px solid #e3f2fd;
            background: white;
            color: #1976d2;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
            white-space: nowrap;
            text-align: center;
            display: flex;
            align-items: center;
            justify-content: center;
        }
        
        .btn-group .btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 8px rgba(0,0,0,0.15);
            border-color: #1976d2;
        }
        
        .btn-group .btn.active {
            background: linear-gradient(135deg, #1976d2, #0056b3);
            border-color: #0056b3;
            color: white;
            transform: translateY(-2px);
            box-shadow: 0 4px 12px rgba(25, 118, 210, 0.4);
        }
        
        .btn-group .btn i {
            margin-right: 6px;
        }
        
        /* Scroll horizontal en m√≥viles para filtros */
        @media (max-width: 768px) {
            .filter-container {
                position: sticky;
                top: 0;
                padding: 8px 0;
                margin: 0 -15px 15px -15px;
                padding-left: 10px;
                padding-right: 10px;
                overflow: hidden;
            }
            
            .btn-group {
                flex-wrap: nowrap;
                overflow-x: auto;
                overflow-y: hidden;
                padding: 12px 0;
                gap: 10px;
                justify-content: flex-start;
                scrollbar-width: none;
                -ms-overflow-style: none;
                padding-bottom: 16px; /* Espacio para evitar corte */
            }
            
            .btn-group::-webkit-scrollbar {
                display: none;
            }
            
            .btn-group .btn {
                flex: none;
                min-width: 120px;
                max-width: 140px;
                white-space: nowrap;
                font-size: 0.85rem;
                padding: 12px 14px;
                line-height: 1.3;
                overflow: hidden;
                text-overflow: ellipsis;
            }
            
            .btn-group .btn.all-combo {
                min-width: 90px;
                max-width: 110px;
                font-size: 0.8rem;
            }
            
            .btn-group .btn i {
                margin-right: 3px;
                font-size: 0.8em;
            }
        }
        
        /* Estilos adicionales para tablets */
        @media (min-width: 769px) and (max-width: 1024px) {
            .btn-group .btn {
                min-width: 160px;
                max-width: 200px;
                font-size: 0.85rem;
            }
        }
        
        /* Estilos espec√≠ficos para desktop */
        @media (min-width: 1025px) {
            .btn-group {
                max-width: 1200px;
                margin: 0 auto;
                justify-content: center;
            }
            
            .btn-group .btn {
                min-width: 160px;
                max-width: 180px;
                font-size: 0.85rem;
                margin: 4px;
            }
            
            .btn-group .btn.all-combo {
                min-width: 120px;
                max-width: 140px;
            }
        }
        
        .offers-list {
            max-height: 600px;
            overflow-y: auto;
            padding-right: 10px;
        }
        
        .offers-list::-webkit-scrollbar {
            width: 8px;
        }
        
        .offers-list::-webkit-scrollbar-track {
            background: #f1f1f1;
            border-radius: 10px;
        }
        
        .offers-list::-webkit-scrollbar-thumb {
            background: #888;
            border-radius: 10px;
        }
        
        .offers-list::-webkit-scrollbar-thumb:hover {
            background: #555;
        }
        
        /* Animaciones para filtros */
        @keyframes fadeIn {
            from { opacity: 0; transform: translateY(10px); }
            to { opacity: 1; transform: translateY(0); }
        }
        
        /* Mejoras adicionales para tarjetas de ofertas en m√≥viles */
        @media (max-width: 576px) {
            .filter-container {
                margin: 0 -10px 15px -10px;
                padding-left: 5px;
                padding-right: 5px;
            }
            
            .btn-group {
                gap: 6px;
                padding: 6px 0 10px 0;
            }
            
            .btn-group .btn {
                min-width: 105px;
                max-width: 125px;
                font-size: 0.8rem;
                padding: 10px 12px;
            }
            
            .btn-group .btn.all-combo {
                min-width: 80px;
                max-width: 95px;
                font-size: 0.75rem;
            }
            
            .offer-card .card-body {
                padding: 12px;
            }
            
            .offer-card .row {
                --bs-gutter-x: 0.5rem;
            }
            
            .offer-rank .badge {
                font-size: 0.8rem;
                padding: 6px 8px;
            }
            
            .price-info h5 {
                font-size: 1.2rem;
            }
            
            .date-info {
                font-size: 0.8rem;
            }
            
            .route-info {
                font-size: 0.75rem;
                overflow: visible;
                white-space: normal;
            }
            
            .route-info small {
                white-space: normal;
                word-break: break-word;
                display: block;
            }
        }
        
        /* Indicador de scroll para filtros en m√≥viles */
        .filter-container::after {
            content: "";
            position: absolute;
            right: 0;
            top: 50%;
            transform: translateY(-50%);
            width: 20px;
            height: 100%;
            background: linear-gradient(to right, transparent, rgba(255,255,255,0.9));
            pointer-events: none;
            opacity: 0;
            transition: opacity 0.3s ease;
        }
        
        @media (max-width: 768px) {
            .filter-container::after {
                opacity: 1;
            }
            
            .offer-card .card {
                min-height: 160px;
            }
        }
        
        /* Estilo para el contador de resultados */
        .results-counter {
            border-radius: 15px;
            border: none;
            background: linear-gradient(135deg, #e3f2fd, #f3e5f5);
            color: #1976d2;
            font-size: 0.9rem;
            padding: 10px 15px;
        }
        
        .results-counter i {
            margin-right: 8px;
        }
        
        /* Animaci√≥n pulse para indicador de scroll */
        @keyframes pulse {
            0% { transform: translateY(-50%) scale(1); opacity: 0.8; }
            50% { transform: translateY(-50%) scale(1.1); opacity: 1; }
            100% { transform: translateY(-50%) scale(1); opacity: 0.8; }
        }
    </style>
</head>
<body>
    <!-- Toast de confirmaci√≥n de copiado -->
    <div id="copy-toast" style="display:none;position:fixed;top:30px;left:50%;transform:translateX(-50%);background:#ffc107;color:#333;padding:12px 32px;border-radius:8px;box-shadow:0 2px 8px rgba(0,0,0,0.15);z-index:9999;font-weight:bold;">
        Mensaje copiado al portapapeles
    </div>
    <div class="container mt-4">
        <div class="row justify-content-center">
            <div class="col-12 text-center">
                <h1 class="header-title">
                    <i class="bi bi-airplane-engines"></i> MMM - Congreso Centroamericano 2026 - Comparador de Ofertas de Vuelos - Copa Airlines<br>
                    <small class="text-muted" style="font-size: 0.6em;">90 Combinaciones de Fechas Disponibles</small>
                </h1>
            </div>
        </div>
            <div class="row justify-content-center">
                <div class="col-12 col-md-8 col-lg-6">
                    <button class="btn btn-primary btn-lg w-100" id="fetch-button" style="display:none">
                        <i class="bi bi-airplane-fill"></i> ¬°Buscar Ofertas de Vuelos Ahora!
                    </button>
                    
                    <!-- Informaci√≥n de reintento autom√°tico -->
                    <div class="alert alert-warning mt-2" id="auto-retry-info" style="display:none">
                        <div class="text-center">
                            <i class="bi bi-clock"></i>
                            <strong>Algunas ciudades fallan. Reintento autom√°tico en:</strong><br>
                            <span id="retry-countdown" class="badge bg-warning text-dark">-</span>
                            <br><small class="text-muted mt-1 d-block">El sistema reintentar√° autom√°ticamente las ciudades que fallaron</small>
                        </div>
                    </div>
                </div>
            </div>
            <!-- Progress Bar -->
            <div class="loading-progress" id="loading">
                <div class="progress" role="progressbar" aria-label="Progreso de b√∫squeda" aria-valuenow="0" aria-valuemin="0" aria-valuemax="100">
                    <div class="progress-bar bg-primary" style="width: 0%;" id="progress-bar"></div>
                </div>
                <p class="mt-2 text-center" id="progress-text">Buscando las mejores ofertas para todas las combinaciones de fechas y destinos... Progreso: 0%</p>
            </div>
            <!-- Error Alert -->
            <div class="alert alert-danger error-alert" role="alert" id="error">
                <i class="bi bi-exclamation-triangle-fill"></i>
                <span id="error-message"></span>
            </div>
            <!-- Global Cheapest Offer -->
            <div class="row justify-content-center global-offer-container" id="global-cheapest-section">
                <div class="col-12">
                    <div class="card global-cheapest-card" id="global-cheapest-info" style="display: none;">
                        <div class="card-body">
                            <div class="row align-items-center">
                                <!-- Columna izquierda: Informaci√≥n de la oferta -->
                                <div class="col-lg-8 col-md-12">
                                    <div class="text-center text-lg-start">
                                        <h5 class="global-title"><i class="bi bi-trophy"></i> Mejor Oferta Global</h5>
                                        <div class="global-city">[CIUDAD]</div>
                                        <div class="global-dates">[FECHAS]</div>
                                        <div class="global-price">$[PRECIO] USD</div>
                                    </div>
                                    
                                    <!-- Mensaje para copiar -->
                                    <div class="mt-3">
                                        <div class="pre-formatted" id="cheapest-message">üåç‚úàÔ∏è ¬°Atenci√≥n pastores y hermanos!
üî• Aprovechen esta s√∫per oferta üî•
üëâ Pasajes stopover en Panam√°: [ITINERARIO]
[STOPOVER_TYPE] | üíµ Todo a [PRECIO] USD
‚ú® ¬°No dejen pasar esta oportunidad! ‚ú®</div>
                                    </div>
                                    
                                    <!-- Bot√≥n -->
                                    <div class="text-center text-lg-start mt-3">
                                        <button class="btn btn-primary" onclick="copyCheapestMessage()">
                                            <i class="bi bi-clipboard"></i> Copiar mensaje
                                        </button>
                                    </div>
                                </div>
                                
                                <!-- Columna derecha: Imagen generada -->
                                <div class="col-lg-4 col-md-12">
                                    <div class="mt-4 mt-lg-0 offer-image-container" id="offer-image-container" style="display: none;">
                                        
                                        <img src="" alt="Oferta Visual" class="offer-image" id="offer-image">
                                    </div>
                                </div>
                            </div>
                        </div>
                    </div>
                </div>
            </div>
            <!-- Individual Cheapest Offers -->
            <div class="row justify-content-center" id="individual-offers-section">
                <div class="col-12">
                    <!-- Estad√≠sticas de resumen -->
                    <div class="summary-stats" id="summary-stats" style="display: none;">
                        <h5><i class="bi bi-graph-up"></i> Resumen de B√∫squeda</h5>
                        <div class="row">
                            <div class="col-md-3 col-6 text-center">
                                <div class="stat-item">
                                    <h6 class="text-success">Ofertas Encontradas</h6>
                                    <span class="badge bg-success" id="found-count">0</span>
                                </div>
                            </div>
                            <div class="col-md-3 col-6 text-center">
                                <div class="stat-item">
                                    <h6 class="text-danger">Con Errores</h6>
                                    <span class="badge bg-danger" id="error-count">0</span>
                                </div>
                            </div>
                            <div class="col-md-3 col-6 text-center">
                                <div class="stat-item">
                                    <h6 class="text-primary">Precio M√≠nimo</h6>
                                    <span class="badge bg-primary" id="min-price">-</span>
                                </div>
                            </div>
                            <div class="col-md-3 col-6 text-center">
                                <div class="stat-item">
                                    <h6 class="text-secondary">Precio M√°ximo</h6>
                                    <span class="badge bg-secondary" id="max-price">-</span>
                                </div>
                            </div>
                        </div>
                    </div>
                    
                    <!-- Pesta√±as de fechas -->
                    <div class="date-tabs text-center" id="date-tabs" style="display: none;">
                        <!-- Las pesta√±as se generar√°n din√°micamente -->
                    </div>
                    
                    <!-- Contenido de fechas -->
                    <div id="date-contents">
                        <!-- El contenido se generar√° din√°micamente -->
                    </div>
                </div>
            </div>
        </div>
    <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.3/dist/js/bootstrap.bundle.min.js" integrity="sha384-YvpcrYf0tY3lHB60NNkmXc5s9fDVZLESaAA55NDzOxhy9GkcIdslK1eN7N6jIeHz" crossorigin="anonymous"></script>

    <script>
        // Funci√≥n para mostrar informaci√≥n de reintento autom√°tico pendiente
        function displayPendingRetry(pendingRetry) {
            const autoRetryInfo = document.getElementById('auto-retry-info');
            const retryCountdown = document.getElementById('retry-countdown');
            
            if (pendingRetry && pendingRetry.minutesUntilRetry > 0) {
                retryCountdown.textContent = `${pendingRetry.minutesUntilRetry} minuto${pendingRetry.minutesUntilRetry > 1 ? 's' : ''}`;
                autoRetryInfo.style.display = 'block';
                
                console.log(`APIs pendientes de reintento: ${pendingRetry.failedApis.join(', ')} - ${pendingRetry.minutesUntilRetry} minutos restantes`);
            } else {
                autoRetryInfo.style.display = 'none';
            }
        }
        
        function copyCheapestMessage() {
            const msg = document.getElementById('cheapest-message');
            if (msg) {
                // Eliminar espacios extra y copiar solo el texto visible
                const text = msg.innerText.replace(/\n\s+/g, '\n').trim();
                navigator.clipboard.writeText(text)
                    .then(() => {
                        showCopyToast();
                    })
                    .catch(() => {
                        showCopyToast('No se pudo copiar el mensaje', true);
                    });
            }
        }

        function showCopyToast(msg = 'Mensaje copiado al portapapeles', error = false) {
            const toast = document.getElementById('copy-toast');
            toast.textContent = msg;
            toast.style.background = error ? '#dc3545' : '#ffc107';
            toast.style.color = error ? '#fff' : '#333';
            toast.style.display = 'block';
            setTimeout(() => {
                toast.style.display = 'none';
            }, 1800);
        }

        function showErrorToast(failedCities) {
            if (failedCities.length === 0) return;
            
            const toast = document.getElementById('copy-toast');
            toast.textContent = `B√∫squeda fall√≥ en: ${failedCities.join(', ')}`;
            toast.style.background = '#dc3545';
            toast.style.color = '#fff';
            toast.style.display = 'block';
            setTimeout(() => {
                toast.style.display = 'none';
            }, 3000);
        }
        document.addEventListener('DOMContentLoaded', () => {
            initializeApp();
        });
        async function fetchOffers() {
            const fetchButton = document.getElementById('fetch-button');
            const loading = document.getElementById('loading');
            const progressBar = document.getElementById('progress-bar');
            const progressText = document.getElementById('progress-text');
            const errorDiv = document.getElementById('error');
            const globalCheapestInfo = document.getElementById('global-cheapest-info');
            const summaryStats = document.getElementById('summary-stats');
            const dateTabs = document.getElementById('date-tabs');
            const dateContents = document.getElementById('date-contents');

            // Deshabilitar bot√≥n y cambiar texto solo si existe
            if (fetchButton) {
                fetchButton.disabled = true;
                fetchButton.innerHTML = '<i class="bi bi-hourglass-split"></i> Buscando...';
            }

            // Mostrar barra de progreso y ocultar elementos previos
            loading.style.display = 'block';
            progressBar.style.width = '10%';
            progressText.textContent = 'Iniciando b√∫squeda de 90 combinaciones... Progreso: 10%';
            errorDiv.style.display = 'none';
            globalCheapestInfo.style.display = 'none';
            summaryStats.style.display = 'none';
            dateTabs.style.display = 'none';
            
            // Limpiar contenido previo
            dateTabs.innerHTML = '';
            dateContents.innerHTML = '';

            try {
                // Iniciar progreso en 10% (inicio de b√∫squeda)
                let progress = 10;
                progressBar.style.width = `${progress}%`;
                progressText.textContent = `Buscando 90 combinaciones de fechas y destinos... Progreso: ${progress}%`;
                
                const updateProgress = (newProgress) => {
                    progress = newProgress;
                    progressBar.style.width = `${progress}%`;
                    progressText.textContent = `Procesando 90 combinaciones de fechas... Progreso: ${Math.round(progress)}%`;
                };

                // Verificar si hay APIs fallidas previas para reintentar
                let apiUrl = '/api/offers';
                const failedApis = localStorage.getItem('failedApis');
                let estimatedTime = 25000; // 25 segundos para 90 combinaciones
                
                // Agregar timestamp para evitar cache del navegador
                const timestamp = new Date().getTime();
                const separator = apiUrl.includes('?') ? '&' : '?';
                apiUrl += `${separator}_t=${timestamp}`;
                
                if (failedApis) {
                    const parsedFailed = JSON.parse(failedApis);
                    if (parsedFailed.length > 0) {
                        apiUrl += `&retry=${parsedFailed.join(',')}`;
                        console.log(`Reintentando b√∫squeda en ciudades: ${parsedFailed.join(', ')}`);
                        progressText.textContent = `Reintentando b√∫squeda en ciudades pendientes... Progreso: ${progress}%`;
                        estimatedTime = parsedFailed.length * 1800; // 1.8 segundos por API fallida
                    }
                }
                
                // Simular progreso incremental durante las llamadas a APIs
                const startTime = Date.now();
                const progressInterval = setInterval(() => {
                    const elapsed = Date.now() - startTime;
                    const timeProgress = (elapsed / estimatedTime) * 85; // 85% del progreso total
                    const newProgress = Math.min(10 + timeProgress, 90); // M√°ximo 90% durante simulaci√≥n
                    updateProgress(newProgress);
                    
                    if (newProgress >= 90) {
                        clearInterval(progressInterval);
                    }
                }, 250); // Actualizar cada 250ms

                let data;
                try {
                    const response = await fetch(apiUrl);
                    clearInterval(progressInterval); // Detener simulaci√≥n al recibir respuesta
                    updateProgress(95); // 95% al recibir respuesta
                    if (!response.ok) throw new Error(`HTTP error: ${response.status}`);
                    data = await response.json();
                    updateProgress(98); // 98% al procesar respuesta
                } catch (error) {
                    clearInterval(progressInterval); // Asegurarse de detener simulaci√≥n en caso de error
                    throw error;
                }

                if (data.error) {
                    throw new Error(data.error);
                }
                
                // Gestionar ciudades con b√∫squeda fallida
                if (data.failedApis && data.failedApis.length > 0) {
                    console.log(`Ciudades con b√∫squeda fallida: ${data.failedApis.join(', ')}`);
                    
                    // Mostrar error espec√≠fico cuando fallen algunas ciudades
                    errorDiv.innerHTML = `<i class="bi bi-exclamation-triangle-fill"></i> Fall√≥ la b√∫squeda con algunas combinaciones - Reintento autom√°tico en 5 minutos`;
                    errorDiv.style.display = 'block';
                } else if (data.pendingRetry) {
                    // Mostrar informaci√≥n de reintento pendiente
                    displayPendingRetry(data.pendingRetry);
                }

                // Progreso completado (100%)
                updateProgress(100);
                progressText.textContent = `¬°B√∫squeda completada! 90 combinaciones procesadas - Progreso: 100%`;

                // Procesar los 90 itinerarios din√°micamente
                console.log('\nüéØ INICIANDO PROCESAMIENTO DE ITINERARIOS');
                console.log('üìä Total de claves en data:', Object.keys(data).length);
                console.log('üõ´ Itinerarios encontrados:', Object.keys(data).filter(k => k.startsWith('itinerary')).length);
                console.log('üìã Estructura completa de data:', data);
                
                // Log de ejemplo de un itinerario para ver estructura
                const firstItinerary = Object.keys(data).find(k => k.startsWith('itinerary'));
                if (firstItinerary) {
                    console.log(`üì¶ EJEMPLO DE ESTRUCTURA - ${firstItinerary}:`, data[firstItinerary]);
                    if (data[firstItinerary].cheapest && data[firstItinerary].cheapest.segments) {
                        console.log('üõ´ Segmentos del primer itinerario:', data[firstItinerary].cheapest.segments);
                    }
                }
                
                // Extraer y organizar los datos por combinaciones de fechas
                const dateCombo = organizeDataByDates(data);
                
                // Generar estad√≠sticas de resumen
                const stats = generateSummaryStats(data);
                updateSummaryStats(stats);
                
                // Mostrar oferta m√°s barata global
                if (data.globalCheapest) {
                    console.log('üèÜ Datos de oferta global encontrados:', data.globalCheapest);
                    await displayGlobalCheapest(data.globalCheapest);
                } else {
                    console.log('‚ö†Ô∏è No se encontraron datos de oferta global');
                }
                
                // Generar interfaz din√°mica
                generateDynamicInterface(dateCombo);
                
                // Mostrar elementos finales
                summaryStats.style.display = 'block';
                dateTabs.style.display = 'block';

                // Recopilar errores de ciudades para mostrar en toast
                const failedCities = [];
                Object.keys(data).filter(k => k.startsWith('itinerary')).forEach(key => {
                    const itinerary = data[key];
                    if (itinerary.error) {
                        failedCities.push(`${itinerary.city || 'Ciudad'} (${itinerary.stopover || 'stopover'})`);
                    }
                });
                
                // Mostrar toast con ciudades fallidas si las hay
                if (failedCities.length > 0) {
                    showErrorToast(failedCities);
                }

            } catch (error) {
                errorDiv.innerHTML = `<i class="bi bi-exclamation-triangle-fill"></i> ${error.message}`;
                errorDiv.style.display = 'block';
            } finally {
                loading.style.display = 'none';
                fetchButton.disabled = false;
                fetchButton.innerHTML = '<i class="bi bi-search"></i> Actualizar B√∫squeda';
            }
        }

        // Funci√≥n para generar la imagen basada en el dise√±o proporcionado
        async function generateOfferImage(data) {
            console.log('Debug generateOfferImage - datos recibidos:', data);
            console.log('Debug generateOfferImage - segments:', data.segments);
            
            // Funci√≥n para parsear fecha localmente (evita desfase por zona horaria)
            function parseLocalDate(dateStr) {
                const [year, month, day] = dateStr.split('-').map(Number);
                return new Date(year, month - 1, day);
            }
            
            // Funci√≥n para convertir hora 24h a formato AM/PM
            function formatTimeAMPM(time24) {
                if (!time24 || typeof time24 !== 'string') return time24;
                
                const [hours, minutes] = time24.split(':');
                const hour = parseInt(hours, 10);
                const ampm = hour >= 12 ? 'PM' : 'AM';
                const hour12 = hour % 12 || 12;
                
                return `${hour12}:${minutes} ${ampm}`;
            }
            
            // Canvas inicial con altura temporal
            const canvas = document.createElement('canvas');
            canvas.width = 900;
            canvas.height = 800; // Altura temporal, se ajustar√° al final
            const ctx = canvas.getContext('2d');

            // Fondo y borde
            ctx.fillStyle = '#fff';
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            ctx.strokeStyle = '#e0e0e0';
            ctx.lineWidth = 2;
            ctx.strokeRect(0, 0, canvas.width, canvas.height);

            // Tarifa restrictiva
            ctx.save();
            ctx.shadowColor = '#a85c1c';
            ctx.shadowBlur = 8;
            ctx.fillStyle = '#a85c1c';
            ctx.font = 'bold 16px Arial';
            ctx.beginPath();
            ctx.roundRect(650, 18, 180, 32, 12);
            ctx.fill();
            ctx.shadowBlur = 0;
            ctx.restore();
            ctx.fillStyle = '#fff';
            ctx.font = 'bold 15px Arial';
            ctx.fillText('Tarifa restrictiva', 670, 40);
            ctx.fillStyle = '#a85c1c';
            ctx.font = 'bold 22px Arial';
            ctx.fillText('üîí', 800, 40);

            // Agrupar segmentos con escala en PTY
            // Agrupar solo los tramos de regreso si el segundo tramo tiene escala en PTY
            let groupedSegments = [];
            if (data.segments && Array.isArray(data.segments)) {
                let i = 0;
                while (i < data.segments.length) {
                    const seg = data.segments[i];
                    // Si el campo stops contiene "1 escala" y el siguiente segmento existe y es la continuaci√≥n
                    if (
                        seg.stops && seg.stops.toLowerCase().includes('1 escala') &&
                        i < data.segments.length - 1 &&
                        seg.to === 'PTY' && data.segments[i + 1].from === 'PTY'
                    ) {
                        // Agrupar ambos como un solo vuelo, eliminando PTY como origen y destino
                        const nextSeg = data.segments[i + 1];
                        // Fusionar CLO - PTY y PTY - LIM como CLO - LIM
                        let fromCity = seg.from;
                        let toCity = nextSeg.to;
                        // Si el primer segmento termina en PTY y el segundo empieza en PTY, fusionar origen y destino reales
                        if (seg.to === 'PTY' && nextSeg.from === 'PTY') {
                            fromCity = seg.from;
                            toCity = nextSeg.to;
                        }
                        groupedSegments.push({
                            date: nextSeg.date,
                            from: fromCity,
                            departure: seg.departure,
                            to: toCity,
                            arrival: nextSeg.arrival,
                            class: nextSeg.class,
                            direct: false,
                            stops: seg.stops,
                            flightNumber: seg.flightNumber + ' / ' + nextSeg.flightNumber,
                            aircraft: seg.aircraft + ' / ' + nextSeg.aircraft
                        });
                        i += 2;
                    } else {
                        // Mostrar segmento individual
                        groupedSegments.push(seg);
                        i++;
                    }
                }
            }

            // Segmentos de vuelo visuales
            let y = 70;
            if (groupedSegments.length > 0) {
                groupedSegments.forEach((seg, idx) => {
                    // Formatear fecha en formato largo (local)
                    let fecha = parseLocalDate(seg.date);
                    let fechaStr = fecha.toLocaleDateString('es-ES', { weekday: 'short', year: 'numeric', month: 'short', day: 'numeric' });
                    if (!seg.direct && seg.stops && seg.stops.toLowerCase().includes('1 escala')) {
                        // VUELO AGRUPADO VISUAL ESPECIAL
                        ctx.fillStyle = '#333';
                        ctx.font = 'bold 15px Arial';
                        ctx.fillText(fechaStr, 40, y);
                        // Icono avi√≥n y texto escala
                        ctx.font = '16px Arial';
                        ctx.fillStyle = '#888';
                        ctx.fillText('‚úà Escala en PTY', 180, y);
                        ctx.font = 'italic 14px Arial';
                        ctx.fillStyle = '#888';
                        // Duraci√≥n escala si est√° disponible
                        let escalaDur = '';
                        let match = seg.stops.match(/\(([^)]+)\)/);
                        if (match) escalaDur = match[1];
                        if (escalaDur) ctx.fillText(`(${escalaDur})`, 320, y);
                        y += 28;
                        // Ruta y horas
                        ctx.font = 'bold 20px Arial';
                        ctx.fillStyle = '#222';
                        ctx.fillText(seg.from, 40, y);
                        ctx.font = 'bold 18px Arial';
                        ctx.fillText(formatTimeAMPM(seg.departure), 120, y);
                        ctx.font = 'bold 28px Arial';
                        ctx.fillStyle = '#bbb';
                        ctx.fillText('‚Üí', 200, y);
                        ctx.font = 'bold 20px Arial';
                        ctx.fillStyle = '#222';
                        ctx.fillText(seg.to, 240, y);
                        ctx.font = 'bold 18px Arial';
                        ctx.fillText(formatTimeAMPM(seg.arrival), 320, y);
                        // Clase en azul
                        ctx.font = '15px Arial';
                        ctx.fillStyle = '#1976d2';
                        ctx.fillText(seg.class || 'Econ√≥mica Basic', 40, y + 22);
                        y += 58; // M√°s espacio antes del separador
                        // Separador visual con mejor espaciado
                        ctx.strokeStyle = '#d0d0d0';
                        ctx.lineWidth = 1;
                        ctx.beginPath();
                        ctx.moveTo(40, y - 20);
                        ctx.lineTo(520, y - 20);
                        ctx.stroke();
                        y += 10; // Espacio despu√©s del separador
                    } else {
                        // VUELO NORMAL
                        ctx.fillStyle = '#333';
                        ctx.font = 'bold 16px Arial';
                        ctx.fillText(fechaStr, 40, y);
                        ctx.font = 'italic 14px Arial';
                        ctx.fillStyle = seg.direct ? '#28a745' : '#ff9800';
                        ctx.fillText(seg.direct ? 'Sin escalas' : seg.stops, 320, y);
                        y += 26;
                        // Ruta y horas
                        ctx.font = 'bold 20px Arial';
                        ctx.fillStyle = '#222';
                        ctx.fillText(seg.from, 40, y);
                        ctx.font = 'bold 18px Arial';
                        ctx.fillText(formatTimeAMPM(seg.departure), 120, y);
                        ctx.font = 'bold 24px Arial';
                        ctx.fillStyle = '#0056b3';
                        ctx.fillText('‚Üí', 200, y);
                        ctx.font = 'bold 20px Arial';
                        ctx.fillStyle = '#222';
                        ctx.fillText(seg.to, 240, y);
                        ctx.font = 'bold 18px Arial';
                        ctx.fillText(formatTimeAMPM(seg.arrival), 320, y);
                        // Clase y n√∫mero de vuelo
                        ctx.font = '14px Arial';
                        ctx.fillStyle = '#0056b3';
                        ctx.fillText(seg.class || 'Econ√≥mica Basic', 40, y + 20);
                        ctx.fillStyle = '#666';
                        if (seg.flightNumber && seg.flightNumber !== 'undefined') {
                            ctx.fillText(`Vuelo: ${seg.flightNumber}`, 240, y + 20);
                        }
                        ctx.font = '13px Arial';
                        ctx.fillStyle = '#888';
                        if (seg.aircraft && seg.aircraft !== 'undefined') {
                            ctx.fillText(seg.aircraft, 420, y + 20);
                        }
                        y += 52; // M√°s espacio antes del separador
                        // Separador visual con mejor espaciado
                        ctx.strokeStyle = '#d0d0d0';
                        ctx.lineWidth = 1;
                        ctx.beginPath();
                        ctx.moveTo(40, y - 20);
                        ctx.lineTo(520, y - 20);
                        ctx.stroke();
                        y += 10; // Espacio despu√©s del separador
                    }
                });
            }

            // Precio destacado y bot√≥n estilo Google Flights
            ctx.textAlign = 'left';
            ctx.fillStyle = '#333';
            ctx.font = 'bold 20px Arial';
            ctx.fillText('Precio por adulto', 600, 120);
            ctx.font = 'bold 40px Arial';
            ctx.fillStyle = '#1976d2';
            ctx.fillText(`${data.price} USD`, 600, 170);
            ctx.font = '20px Arial';
            ctx.fillStyle = '#666';
            ctx.fillText('Clase Econ√≥mica', 600, 200);

            // Ver detalles (en azul, subrayado)
            ctx.font = '18px Arial';
            ctx.fillStyle = '#1976d2';
            ctx.fillText('Ver detalles', 600, 235);

            // Calcular altura real necesaria basada en el contenido dibujado
            let contentHeight = Math.max(y, 255); // y de los vuelos vs posici√≥n fija del precio
            contentHeight += 30; // Padding inferior
            
            // Crear canvas final con altura optimizada
            const finalCanvas = document.createElement('canvas');
            finalCanvas.width = canvas.width;
            finalCanvas.height = contentHeight;
            const finalCtx = finalCanvas.getContext('2d');
            
            // Copiar contenido al canvas final (recortado)
            finalCtx.drawImage(canvas, 0, 0, canvas.width, contentHeight, 0, 0, finalCanvas.width, finalCanvas.height);

            // Convertir a imagen el canvas optimizado
            return finalCanvas.toDataURL('image/png');
        }

        // Funci√≥n para organizar datos por combinaciones de fechas
        function organizeDataByDates(data) {
            console.log('\nüìÖ ORGANIZANDO DATOS POR FECHAS');
            const dateCombo = {};
            
            const itineraryKeys = Object.keys(data).filter(k => k.startsWith('itinerary'));
            console.log(`üìä Procesando ${itineraryKeys.length} itinerarios...`);
            
            itineraryKeys.forEach((key, index) => {
                const itinerary = data[key];
                console.log(`\nüì¶ Procesando ${key} (${index + 1}/${itineraryKeys.length})`);
                console.log('üìã Itinerary data:', itinerary);
                
                if (itinerary && itinerary.dateComboId) {
                    const comboId = itinerary.dateComboId;
                    console.log(`üîó ComboId: ${comboId}`);
                    
                    if (!dateCombo[comboId]) {
                        dateCombo[comboId] = {
                            searchDate: itinerary.searchDate,
                            returnDate: itinerary.returnDate,
                            itineraries: []
                        };
                        console.log(`‚ú® Creado nuevo combo: ${comboId}`);
                    }
                    
                    dateCombo[comboId].itineraries.push(itinerary);
                    console.log(`‚ûï Agregado a combo ${comboId} (total: ${dateCombo[comboId].itineraries.length})`);
                    
                    // Log de segments si est√°n disponibles
                    if (itinerary.cheapest && itinerary.cheapest.segments) {
                        console.log(`üõ´ Segmentos disponibles para ${key}:`, itinerary.cheapest.segments);
                    } else {
                        console.warn(`‚ö†Ô∏è No hay segments para ${key}`);
                    }
                } else {
                    console.warn(`‚ö†Ô∏è ${key} no tiene dateComboId v√°lido:`, itinerary);
                }
            });
            
            console.log('\nüìä RESUMEN DE ORGANIZACI√ìN:');
            Object.keys(dateCombo).forEach(comboId => {
                console.log(`   ${comboId}: ${dateCombo[comboId].itineraries.length} itinerarios`);
            });
            
            return dateCombo;
        }

        // Funci√≥n para generar estad√≠sticas de resumen
        function generateSummaryStats(data) {
            const stats = {
                total: 0,
                successful: 0,
                failed: 0,
                cheapestPrice: Infinity,
                avgPrice: 0,
                cities: new Set(),
                combinations: new Set()
            };
            
            let totalPrice = 0;
            
            Object.keys(data).filter(k => k.startsWith('itinerary')).forEach(key => {
                const itinerary = data[key];
                stats.total++;
                
                if (itinerary.error) {
                    stats.failed++;
                } else if (itinerary.cheapest) {
                    stats.successful++;
                    stats.cities.add(itinerary.city);
                    stats.combinations.add(itinerary.dateComboId);
                    
                    const price = parseFloat(itinerary.cheapest.price);
                    if (price < stats.cheapestPrice) {
                        stats.cheapestPrice = price;
                    }
                    totalPrice += price;
                }
            });
            
            if (stats.successful > 0) {
                stats.avgPrice = totalPrice / stats.successful;
            }
            
            return stats;
        }

        // Funci√≥n para actualizar estad√≠sticas en la UI
        function updateSummaryStats(stats) {
            const summaryStats = document.getElementById('summary-stats');
            summaryStats.innerHTML = `
                <div class="row g-4">
                    <div class="col-md-4 col-sm-6">
                        <div class="stat-card">
                            <h5>${stats.total}</h5>
                            <p>B√∫squedas Total</p>
                        </div>
                    </div>
                    <div class="col-md-4 col-sm-6">
                        <div class="stat-card">
                            <h5>${stats.successful}</h5>
                            <p>Exitosas</p>
                        </div>
                    </div>
                    <div class="col-md-4 col-sm-12">
                        <div class="stat-card">
                            <h5>$${stats.cheapestPrice !== Infinity ? stats.cheapestPrice.toFixed(2) : 'N/A'}</h5>
                            <p>Precio M√°s Bajo</p>
                        </div>
                    </div>
                </div>
            `;
        }

        // Funci√≥n global para obtener el c√≥digo del aeropuerto
        function getAirportCode(city) {
            const airportCodes = {
                'Quito': 'UIO',
                'Medell√≠n': 'MDE',
                'Cali': 'CLO',
                'Cartagena': 'CTG',
                'Bogot√°': 'BOG'
            };
            return airportCodes[city] || city;
        }

        // Funci√≥n para mostrar la oferta m√°s barata global
        async function displayGlobalCheapest(cheapest) {
            console.log('üèÜ Mostrando oferta global m√°s barata:', cheapest);
            
            const globalCheapestSection = document.getElementById('global-cheapest-section');
            const globalCheapestInfo = document.getElementById('global-cheapest-info');
            
            if (!globalCheapestSection || !globalCheapestInfo) {
                console.error('‚ùå No se encontraron los elementos de la secci√≥n global');
                return;
            }
            
            // Determinar el texto del stopover
            const stopoverText = cheapest.stopover === 'ida' ? 'Stopover de Ida en Panam√°' : 'Stopover de Regreso en Panam√°';
            
            globalCheapestInfo.innerHTML = `
                <div class="card-body">
                    <div class="row align-items-center">
                        <!-- Columna izquierda: Informaci√≥n de la oferta -->
                        <div class="col-lg-4 col-md-12">
                            <div class="text-center text-lg-start">
                                <h5 class="global-title"><i class="bi bi-trophy"></i> Mejor Oferta Global</h5>
                                <div class="global-city">${cheapest.city} (${getAirportCode(cheapest.city)})</div>
                                <div class="global-dates">Salida: ${formatDateDMY(cheapest.searchDate)} | Regreso: ${formatDateDMY(cheapest.returnDate)}</div>
                                <div class="global-dates">${stopoverText}</div>
                                <div class="global-price">$${cheapest.price} USD</div>
                            </div>
                            
                            <!-- Mensaje para copiar -->
                            <div class="mt-3">
                                <div class="pre-formatted" id="cheapest-message">üéâ OFERTA ESPECIAL - Congreso Centroamericano 2026! üéâ
‚úàÔ∏è Ciudad: ${cheapest.city} | üìÖ ${formatDateDMY(cheapest.searchDate)} - ${formatDateDMY(cheapest.returnDate)}
üîÑ ${stopoverText} | üíµ $${cheapest.price} USD
‚ú® ¬°No dejen pasar esta oportunidad! ‚ú®

üõ´ Ruta: 
${generateRouteForMessage(cheapest.city, stopoverText, cheapest.searchDate, cheapest.returnDate)}</div>
                            </div>
                            
                            <!-- Bot√≥n -->
                            <div class="text-center text-lg-start mt-3">
                                <button class="btn btn-primary btn-lg" onclick="copyCheapestMessage()">
                                    <i class="bi bi-clipboard"></i> Copiar mensaje
                                </button>
                            </div>
                        </div>
                        
                        <!-- Columna derecha: Imagen generada -->
                        <div class="col-lg-8 col-md-12">
                            <div class="mt-4 mt-lg-0 offer-image-container" id="offer-image-container" style="display: none;">
                                
                                <img src="" alt="Oferta Visual" class="offer-image" id="offer-image">
                            </div>
                        </div>
                    </div>
                </div>
            `;
            
            // Mostrar los elementos
            globalCheapestInfo.style.display = 'block';
            globalCheapestSection.style.display = 'block';
            
            console.log('‚úÖ Secci√≥n global mostrada correctamente');
            
            // Generar imagen para la mejor oferta
            if (cheapest.segments && cheapest.segments.length > 0) {
                console.log('Generando imagen para la mejor oferta:', cheapest);
                
                const imageData = {
                    city: cheapest.city,
                    price: cheapest.price,
                    segments: cheapest.segments,
                    searchDate: cheapest.searchDate,
                    returnDate: cheapest.returnDate,
                    stopoverType: cheapest.stopover
                };
                
                console.log('Debug - imageData enviado a generateOfferImage:', imageData);
                
                const generatedImage = await generateOfferImage(imageData);
                if (generatedImage) {
                    // Buscar el contenedor y la imagen dentro del HTML generado din√°micamente
                    setTimeout(() => {
                        const dynamicOfferImage = document.getElementById('offer-image');
                        const dynamicOfferImageContainer = document.getElementById('offer-image-container');
                        
                        if (dynamicOfferImage && dynamicOfferImageContainer) {
                            dynamicOfferImage.src = generatedImage;
                            dynamicOfferImageContainer.style.display = 'block';
                            dynamicOfferImageContainer.classList.add('offer-image-container');
                            console.log('Imagen asignada correctamente al contenedor din√°mico');
                        } else {
                            console.error('No se encontraron los elementos de imagen en el DOM din√°mico');
                        }
                    }, 100);
                }
            }
        }

        // Funci√≥n para generar la interfaz din√°mica
        function generateDynamicInterface(dateCombo) {
            const dateTabs = document.getElementById('date-tabs');
            const dateContents = document.getElementById('date-contents');
            
            // Limpiar contenido previo
            dateTabs.innerHTML = '';
            dateContents.innerHTML = '';
            
            // Crear contenedor principal de filtros
            const mainFilterContainer = document.createElement('div');
            mainFilterContainer.className = 'filter-container';
            
            // Crear t√≠tulo de filtros
            const filterTitle = document.createElement('div');
            filterTitle.className = 'text-center mb-3';
            filterTitle.innerHTML = `
                <h6 class="mb-2">
                    <i class="bi bi-funnel-fill text-primary"></i> 
                    Filtrar por Combinaciones de Fechas
                </h6>
                <small class="text-muted">Desliza horizontalmente para ver m√°s fechas en m√≥viles</small>
            `;
            
            // Crear botones de filtro por fechas
            const filterContainer = document.createElement('div');
            filterContainer.className = 'btn-group';
            filterContainer.setAttribute('role', 'group');
            
            // Bot√≥n "Todas las combinaciones"
            const allButton = document.createElement('button');
            allButton.type = 'button';
            allButton.className = 'btn btn-outline-primary active all-combo';
            allButton.onclick = () => filterByDate('all');
            allButton.innerHTML = `
                <i class="bi bi-grid-3x3-gap"></i> Todas
            `;
            filterContainer.appendChild(allButton);
            
            // Agregar botones para cada combinaci√≥n de fecha
            Object.keys(dateCombo).forEach((comboId, index) => {
                const combo = dateCombo[comboId];
                const button = document.createElement('button');
                button.type = 'button';
                button.className = 'btn btn-outline-primary';
                button.onclick = () => filterByDate(comboId);
                button.setAttribute('data-combo-id', comboId);
                
                // Formatear fechas: sin a√±o para los botones de filtro
                const compactSearchDate = formatDateCompact(combo.searchDate);
                const compactReturnDate = formatDateCompact(combo.returnDate);
                
                button.innerHTML = `
                    <i class="bi bi-calendar-week"></i> 
                    <span class="d-none d-md-inline">${compactSearchDate} ‚Üí ${compactReturnDate}</span>
                    <span class="d-md-none">${compactSearchDate}‚Üí${compactReturnDate}</span>
                `;
                filterContainer.appendChild(button);
            });
            
            mainFilterContainer.appendChild(filterTitle);
            mainFilterContainer.appendChild(filterContainer);
            dateTabs.appendChild(mainFilterContainer);
            
            // Crear lista de todas las ofertas
            const allOffers = [];
            Object.keys(dateCombo).forEach(comboId => {
                const combo = dateCombo[comboId];
                combo.itineraries.forEach(itinerary => {
                    if (itinerary.cheapest) {
                        allOffers.push({
                            ...itinerary,
                            comboId: comboId,
                            searchDate: combo.searchDate,
                            returnDate: combo.returnDate
                        });
                    }
                });
            });
            
            // Ordenar ofertas por precio
            allOffers.sort((a, b) => parseFloat(a.cheapest.price) - parseFloat(b.cheapest.price));
            
            // Generar lista de ofertas
            generateOffersList(allOffers, dateCombo);
        }

        // Funci√≥n para generar grupos de ciudades
        function generateCityGroups(itineraries) {
            const cities = {};
            
            // Agrupar por ciudad
            itineraries.forEach(itinerary => {
                const city = itinerary.city;
                if (!cities[city]) {
                    cities[city] = {
                        ida: null,
                        regreso: null
                    };
                }
                cities[city][itinerary.stopover] = itinerary;
            });
            
            let html = '<div class="row">';
            
            Object.keys(cities).forEach(cityName => {
                const cityData = cities[cityName];
                html += `
                    <div class="col-md-6 mb-4">
                        <div class="city-group">
                            <h5 class="city-name">${cityName}</h5>
                            <div class="stopovers">
                `;
                
                // Stopover de ida
                if (cityData.ida && cityData.ida.cheapest) {
                    html += generateStopoverCard(cityData.ida, 'ida');
                } else {
                    html += `<div class="stopover-card error">
                        <h6>Stopover de Ida en Panam√°</h6>
                        <p>Sin resultados disponibles</p>
                    </div>`;
                }
                
                // Stopover de regreso
                if (cityData.regreso && cityData.regreso.cheapest) {
                    html += generateStopoverCard(cityData.regreso, 'regreso');
                } else {
                    html += `<div class="stopover-card error">
                        <h6>Stopover de Regreso en Panam√°</h6>
                        <p>Sin resultados disponibles</p>
                    </div>`;
                }
                
                html += `
                            </div>
                        </div>
                    </div>
                `;
            });
            
            html += '</div>';
            return html;
        }

        // Funci√≥n para generar tarjeta de stopover
        function generateStopoverCard(itinerary, stopoverType) {
            const data = itinerary.cheapest;
            return `
                <div class="stopover-card">
                    <div class="stopover-header">
                        <h6>Stopover de ${stopoverType.charAt(0).toUpperCase() + stopoverType.slice(1)} en Panam√°</h6>
                        <span class="price">$${data.price}</span>
                    </div>
                    <div class="route-info">
                        <p><strong>Ruta:</strong> ${data.segments ? data.segments.map(s => s.route).join(' ‚Üí ') : 'N/A'}</p>
                        <p><strong>Duraci√≥n:</strong> ${data.totalDuration || 'N/A'}</p>
                    </div>
                </div>
            `;
        }

        // Funci√≥n para obtener el c√≥digo de aeropuerto por ciudad
        function getCityAirportCode(city) {
            const cityCode = city === 'Quito' ? 'UIO' : 
                           city === 'Medell√≠n' ? 'MDE' : 
                           city === 'Cali' ? 'CLO' : 
                           city === 'Cartagena' ? 'CTG' : 
                           city === 'Bogot√°' ? 'BOG' : 
                           city.substring(0, 3).toUpperCase();
            
            console.log(`üèôÔ∏è C√≥digo aeropuerto para ${city}: ${cityCode}`);
            return cityCode;
        }

        // Funci√≥n para convertir c√≥digo de aeropuerto a formato "Ciudad (C√ìDIGO)"
        function getAirportDisplayName(code) {
            const airportMap = {
                'PTY': 'Panam√° (PTY)',
                'LIM': 'Lima (LIM)',
                'UIO': 'Quito (UIO)',
                'MDE': 'Medell√≠n (MDE)',
                'CLO': 'Cali (CLO)',
                'CTG': 'Cartagena (CTG)',
                'BOG': 'Bogot√° (BOG)'
            };
            
            const displayName = airportMap[code] || `${code} (${code})`;
            console.log(`‚úàÔ∏è C√≥digo ${code} convertido a: ${displayName}`);
            return displayName;
        }

        // Funci√≥n para generar ruta para el mensaje de la oferta m√°s barata
        function generateRouteForMessage(city, stopover, searchDate, returnDate) {
            // Funci√≥n auxiliar para formatear fecha a DD/MM
            function formatDateForRoute(dateStr) {
                if (!dateStr) return '';
                const parts = dateStr.split('-');
                if (parts.length === 3) {
                    return `${parts[2]}/${parts[1]}`;
                }
                return dateStr;
            }
            
            const cityCode = city === 'Quito' ? 'UIO' : 
                           city === 'Medell√≠n' ? 'MDE' : 
                           city === 'Cali' ? 'CLO' : 
                           city === 'Cartagena' ? 'CTG' : 
                           city === 'Bogot√°' ? 'BOG' : 
                           city.substring(0, 3).toUpperCase();
            
            const outboundDate = formatDateForRoute(searchDate);
            const returnDateFormatted = formatDateForRoute(returnDate);
            
            // Determinar tipo de stopover
            const isReturnStopover = stopover && stopover.toLowerCase().includes('regreso');
            const isOutboundStopover = stopover && stopover.toLowerCase().includes('ida');
            
            let routeMessage;
            if (isReturnStopover) {
                // QUITO - Stopover de REGRESO en Panam√°
                // Lima (LIM) ‚Üí Quito (UIO) (11/02), Quito (UIO) ‚Üí Panam√° (PTY) (11/02), Panam√° (PTY) ‚Üí Lima (LIM) (18/02)
                routeMessage = `${getAirportDisplayName('LIM')} ‚Üí ${getAirportDisplayName(cityCode)} (${outboundDate})<br>` +
                              `${getAirportDisplayName(cityCode)} ‚Üí ${getAirportDisplayName('PTY')} (${outboundDate})<br>` +
                              `${getAirportDisplayName('PTY')} ‚Üí ${getAirportDisplayName('LIM')} (${returnDateFormatted})`;
            } else if (isOutboundStopover) {
                // MEDELL√çN - Stopover de IDA en Panam√°  
                // Lima (LIM) ‚Üí Panam√° (PTY) (11/02), Panam√° (PTY) ‚Üí Medell√≠n (MDE) (18/02), Medell√≠n (MDE) ‚Üí Lima (LIM) (18/02)
                routeMessage = `${getAirportDisplayName('LIM')} ‚Üí ${getAirportDisplayName('PTY')} (${outboundDate})<br>` +
                              `${getAirportDisplayName('PTY')} ‚Üí ${getAirportDisplayName(cityCode)} (${returnDateFormatted})<br>` +
                              `${getAirportDisplayName(cityCode)} ‚Üí ${getAirportDisplayName('LIM')} (${returnDateFormatted})`;
            } else {
                // Fallback gen√©rico
                routeMessage = `${getAirportDisplayName('LIM')} ‚Üí ${getAirportDisplayName(cityCode)} (${outboundDate})<br>` +
                              `${getAirportDisplayName(cityCode)} ‚Üí ${getAirportDisplayName('LIM')} (${returnDateFormatted})`;
            }
            
            return routeMessage;
        }

        // Funci√≥n para generar la lista de ofertas
        function generateOffersList(allOffers, dateCombo) {
            const dateContents = document.getElementById('date-contents');
            
            let html = '<div class="offers-list" id="offers-list">';
            
            allOffers.forEach((offer, index) => {
                const data = offer.cheapest;
                
                // Debug: verificar estructura de datos
                console.log(`\nüîç PROCESANDO OFERTA #${index + 1} - ${offer.city}`);
                console.log('üì¶ Estructura completa de offer:', offer);
                console.log('üí∞ Data cheapest:', data);
                console.log('üõ´ Segments disponibles:', data?.segments);
                console.log('‚úÖ Tiene segmentos v√°lidos:', data?.segments && Array.isArray(data.segments) && data.segments.length > 0);
                
                // INVESTIGAR ESTRUCTURA ALTERNATIVA DE SEGMENTS
                console.log('üîç BUSCANDO SEGMENTS EN OTRAS UBICACIONES:');
                console.log('   offer.segments:', offer.segments);
                console.log('   data.flight_segments:', data?.flight_segments);
                console.log('   data.route:', data?.route);
                console.log('   data.itinerary:', data?.itinerary);
                console.log('   Claves disponibles en data:', data ? Object.keys(data) : 'data is null/undefined');
                
                if (data?.segments && Array.isArray(data.segments)) {
                    console.log(`üìä Total de segmentos encontrados: ${data.segments.length}`);
                    data.segments.forEach((seg, segIndex) => {
                        console.log(`   Segmento ${segIndex + 1}:`, {
                            from: seg.from,
                            to: seg.to,
                            date: seg.date,
                            stops: seg.stops,
                            hasOneStop: seg.stops && seg.stops.toLowerCase().includes('1 escala'),
                            fullSegment: seg
                        });
                    });
                } else {
                    console.warn('‚ö†Ô∏è No hay segmentos v√°lidos para esta oferta');
                    console.log('üîß INTENTANDO RECONSTRUIR SEGMENTS DESDE OTROS DATOS...');
                    
                    // Intentar encontrar datos de ruta en otras propiedades
                    if (data && typeof data === 'object') {
                        Object.keys(data).forEach(key => {
                            if (key.toLowerCase().includes('segment') || 
                                key.toLowerCase().includes('route') || 
                                key.toLowerCase().includes('flight')) {
                                console.log(`   Posible fuente de segments - ${key}:`, data[key]);
                            }
                        });
                    }
                }
                
                // Generar resumen completo del itinerario respetando fechas de cada segmento
                function generateRouteDescription(segments, city, stopover, searchDate, returnDate) {
                    
                    console.log(`\nüöÄ INICIANDO generateRouteDescription para ${city}`);
                    console.log('üì• Par√°metros recibidos:', {
                        segments: segments,
                        city: city,
                        stopover: stopover,
                        searchDate: searchDate,
                        returnDate: returnDate
                    });
                    
                    // Funci√≥n auxiliar para formatear fecha a DD/MM
                    function formatDateForRoute(dateStr) {
                        if (!dateStr) {
                            console.warn('‚ö†Ô∏è Fecha vac√≠a recibida en formatDateForRoute');
                            return '';
                        }
                        console.log('üìÖ Formateando fecha:', dateStr);
                        const parts = dateStr.split('-');
                        if (parts.length === 3) {
                            const formatted = `${parts[2]}/${parts[1]}`;
                            console.log(`üìÖ Resultado formato: ${dateStr} ‚Üí ${formatted}`);
                            return formatted;
                        }
                        console.warn(`‚ö†Ô∏è Formato de fecha inesperado: ${dateStr}`);
                        return dateStr;
                    }
                    
                    // Validaci√≥n inicial de par√°metros
                    if (!segments) {
                        console.error('‚ùå ERROR: segments es null o undefined');
                        console.log('üîÑ Usando fallback con par√°metros b√°sicos:', { city, stopover, searchDate, returnDate });
                        
                        // FALLBACK MEJORADO: crear ruta b√°sica con los par√°metros disponibles
                        const cityCode = city === 'Quito' ? 'UIO' : 
                                       city === 'Medell√≠n' ? 'MDE' : 
                                       city === 'Cali' ? 'CLO' : 
                                       city === 'Cartagena' ? 'CTG' : 
                                       city === 'Bogot√°' ? 'BOG' : 
                                       city.substring(0, 3).toUpperCase();
                        
                        const outboundDate = formatDateForRoute(searchDate);
                        const returnDateFormatted = formatDateForRoute(returnDate);
                        
                        // Determinar tipo de stopover para generar ruta apropiada
                        const isReturnStopover = stopover && stopover.toLowerCase().includes('regreso');
                        const isOutboundStopover = stopover && stopover.toLowerCase().includes('ida');
                        
                        let fallbackRoute;
                        if (isReturnStopover) {
                            // QUITO - Stopover de REGRESO en Panam√°
                            // LIM ‚Üí UIO (11/02), UIO ‚Üí PTY (11/02), PTY ‚Üí LIM (18/02)
                            fallbackRoute = `${getAirportDisplayName('LIM')} ‚Üí ${getAirportDisplayName(cityCode)} (${outboundDate})<br>${getAirportDisplayName(cityCode)} ‚Üí ${getAirportDisplayName('PTY')} (${outboundDate})<br>${getAirportDisplayName('PTY')} ‚Üí ${getAirportDisplayName('LIM')} (${returnDateFormatted})`;
                            console.log('üéØ Aplicando l√≥gica REGRESO para', city);
                        } else if (isOutboundStopover) {
                            // MEDELL√çN - Stopover de IDA en Panam√°  
                            // LIM ‚Üí PTY (11/02), PTY ‚Üí MDE (18/02), MDE ‚Üí LIM (18/02)
                            fallbackRoute = `${getAirportDisplayName('LIM')} ‚Üí ${getAirportDisplayName('PTY')} (${outboundDate})<br>${getAirportDisplayName('PTY')} ‚Üí ${getAirportDisplayName(cityCode)} (${returnDateFormatted})<br>${getAirportDisplayName(cityCode)} ‚Üí ${getAirportDisplayName('LIM')} (${returnDateFormatted})`;
                            console.log('üéØ Aplicando l√≥gica IDA para', city);
                        } else {
                            // Fallback gen√©rico
                            fallbackRoute = `${getAirportDisplayName('LIM')} ‚Üí ${getAirportDisplayName(cityCode)} (${outboundDate})<br>${getAirportDisplayName(cityCode)} ‚Üí ${getAirportDisplayName('LIM')} (${returnDateFormatted})`;
                            console.log('üéØ Aplicando l√≥gica GEN√âRICA para', city);
                        }
                        
                        console.log('üîÑ Ruta fallback generada:', fallbackRoute);
                        return fallbackRoute;
                    }
                    
                    if (!Array.isArray(segments)) {
                        console.error('‚ùå ERROR: segments no es un array:', typeof segments);
                        return 'Error: Formato de segmentos inv√°lido';
                    }
                    
                    if (segments.length === 0) {
                        console.warn('‚ö†Ô∏è WARNING: segments est√° vac√≠o');
                        console.log('üîÑ Usando fallback para array vac√≠o...');
                        
                        // Mismo fallback que arriba
                        const cityCode = city === 'Quito' ? 'UIO' : 
                                       city === 'Medell√≠n' ? 'MDE' : 
                                       city === 'Cali' ? 'CLO' : 
                                       city === 'Cartagena' ? 'CTG' : 
                                       city === 'Bogot√°' ? 'BOG' : 
                                       city.substring(0, 3).toUpperCase();
                        
                        const outboundDate = formatDateForRoute(searchDate);
                        const returnDateFormatted = formatDateForRoute(returnDate);
                        
                        const isReturnStopover = stopover && stopover.toLowerCase().includes('regreso');
                        const isOutboundStopover = stopover && stopover.toLowerCase().includes('ida');
                        
                        let fallbackRoute;
                        if (isReturnStopover) {
                            // QUITO - Stopover de REGRESO en Panam√°
                            // LIM ‚Üí UIO (11/02), UIO ‚Üí PTY (11/02), PTY ‚Üí LIM (18/02)
                            fallbackRoute = `${getAirportDisplayName('LIM')} ‚Üí ${getAirportDisplayName(cityCode)} (${outboundDate})<br>${getAirportDisplayName(cityCode)} ‚Üí ${getAirportDisplayName('PTY')} (${outboundDate})<br>${getAirportDisplayName('PTY')} ‚Üí ${getAirportDisplayName('LIM')} (${returnDateFormatted})`;
                        } else if (isOutboundStopover) {
                            // MEDELL√çN - Stopover de IDA en Panam√°  
                            // LIM ‚Üí PTY (11/02), PTY ‚Üí MDE (18/02), MDE ‚Üí LIM (18/02)
                            fallbackRoute = `${getAirportDisplayName('LIM')} ‚Üí ${getAirportDisplayName('PTY')} (${outboundDate})<br>${getAirportDisplayName('PTY')} ‚Üí ${getAirportDisplayName(cityCode)} (${returnDateFormatted})<br>${getAirportDisplayName(cityCode)} ‚Üí ${getAirportDisplayName('LIM')} (${returnDateFormatted})`;
                        } else {
                            fallbackRoute = `${getAirportDisplayName('LIM')} ‚Üí ${getAirportDisplayName(cityCode)} (${outboundDate})<br>${getAirportDisplayName(cityCode)} ‚Üí ${getAirportDisplayName('LIM')} (${returnDateFormatted})`;
                        }
                        
                        return fallbackRoute;
                    }
                    
                    // SIEMPRE priorizar los datos reales de segmentos de la API
                    if (segments && Array.isArray(segments) && segments.length > 0) {
                        console.log('=== üõ´ GENERANDO RESUMEN COMPLETO DEL ITINERARIO ===');
                        console.log('üìã Segmentos originales:', JSON.stringify(segments, null, 2));
                        console.log('üîÑ Tipo de stopover:', stopover);
                        console.log('üìä Total de segmentos:', segments.length);
                        
                        // NUEVA L√ìGICA: Analizar tipo de stopover
                        const isReturnStopover = stopover && stopover.toLowerCase().includes('regreso');
                        const isOutboundStopover = stopover && stopover.toLowerCase().includes('ida');
                        
                        console.log('üîç AN√ÅLISIS DE STOPOVER:');
                        console.log(`   ‚îú‚îÄ Es stopover de regreso: ${isReturnStopover}`);
                        console.log(`   ‚îú‚îÄ Es stopover de ida: ${isOutboundStopover}`);
                        console.log(`   ‚îî‚îÄ Texto completo: "${stopover}"`);
                        
                        // Validar estructura de cada segmento
                        let invalidSegments = [];
                        segments.forEach((seg, idx) => {
                            if (!seg.from || !seg.to || !seg.date) {
                                invalidSegments.push({
                                    index: idx,
                                    segment: seg,
                                    missing: {
                                        from: !seg.from,
                                        to: !seg.to,
                                        date: !seg.date
                                    }
                                });
                            }
                        });
                        
                        if (invalidSegments.length > 0) {
                            console.error('‚ùå SEGMENTOS INV√ÅLIDOS ENCONTRADOS:');
                            invalidSegments.forEach(invalid => {
                                console.error(`   Segmento ${invalid.index + 1}:`, invalid);
                            });
                        }
                        
                        let routes = [];
                        
                        // NUEVA ESTRATEGIA: Procesar seg√∫n el tipo de stopover
                        if (isReturnStopover && segments.length >= 3) {
                            console.log('\nüîÑ PROCESANDO STOPOVER DE REGRESO...');
                            
                            // Para stopover de regreso: LIM‚ÜíDEST debe agruparse, DEST‚ÜíPTY‚ÜíLIM individual
                            // Ejemplo Quito: LIM‚ÜíUIO (agrupado), UIO‚ÜíPTY (individual), PTY‚ÜíLIM (individual)
                            
                            // Buscar el primer segmento que va de LIM a PTY con "1 escala"
                            let firstTwoGrouped = false;
                            let i = 0;
                            
                            while (i < segments.length) {
                                const segment = segments[i];
                                console.log(`\nÔøΩ Analizando segmento ${i + 1}: ${segment.from} ‚Üí ${segment.to}`);
                                
                                // Si es el primer segmento LIM‚ÜíPTY con "1 escala" y hay siguiente PTY‚ÜíDEST
                                if (i === 0 && segment.from === 'LIM' && segment.to === 'PTY' && 
                                    segment.stops && segment.stops.includes('1 escala') &&
                                    i + 1 < segments.length && segments[i + 1].from === 'PTY') {
                                    
                                    const nextSegment = segments[i + 1];
                                    const firstDate = formatDateForRoute(segment.date);
                                    const secondDate = formatDateForRoute(nextSegment.date);
                                    
                                    // Agrupar LIM ‚Üí DESTINO con fechas
                                    let dateDisplay = (firstDate === secondDate) ? `(${firstDate})` : `(${firstDate}/${secondDate})`;
                                    const groupedRoute = `${getAirportDisplayName(segment.from)} ‚Üí ${getAirportDisplayName(nextSegment.to)} ${dateDisplay}`;
                                    
                                    console.log(`‚úÖ AGRUPANDO SEGMENTOS 1 y 2: ${groupedRoute}`);
                                    routes.push(groupedRoute);
                                    i += 2;
                                    firstTwoGrouped = true;
                                } else {
                                    // Procesar segmento individual
                                    const segmentDate = formatDateForRoute(segment.date);
                                    const route = `${getAirportDisplayName(segment.from)} ‚Üí ${getAirportDisplayName(segment.to)} (${segmentDate})`;
                                    console.log(`‚û°Ô∏è SEGMENTO INDIVIDUAL: ${route}`);
                                    routes.push(route);
                                    i++;
                                }
                            }
                            
                        } else if (isOutboundStopover && segments.length >= 3) {
                            console.log('\nüîÑ PROCESANDO STOPOVER DE IDA...');
                            
                            // Para stopover de ida: LIM‚ÜíPTY individual, PTY‚ÜíDEST‚ÜíLIM agrupado
                            // Ejemplo Medell√≠n: LIM‚ÜíPTY (individual), PTY‚ÜíMED‚ÜíLIM puede no agruparse si no tiene "1 escala"
                            
                            let i = 0;
                            
                            while (i < segments.length) {
                                const segment = segments[i];
                                console.log(`\nüîç Analizando segmento ${i + 1}: ${segment.from} ‚Üí ${segment.to}`);
                                
                                // Buscar agrupaciones con "1 escala" independientemente de la posici√≥n
                                const hasOneStop = segment.stops && segment.stops.toLowerCase().includes('1 escala');
                                const hasNextSegment = i < segments.length - 1;
                                const nextSegment = hasNextSegment ? segments[i + 1] : null;
                                
                                if (hasOneStop && hasNextSegment && segment.to === 'PTY' && nextSegment.from === 'PTY') {
                                    // Agrupar este segmento con el siguiente
                                    const firstDate = formatDateForRoute(segment.date);
                                    const secondDate = formatDateForRoute(nextSegment.date);
                                    
                                    let dateDisplay = (firstDate === secondDate) ? `(${firstDate})` : `(${firstDate}/${secondDate})`;
                                    const groupedRoute = `${getAirportDisplayName(segment.from)} ‚Üí ${getAirportDisplayName(nextSegment.to)} ${dateDisplay}`;
                                    
                                    console.log(`‚úÖ AGRUPANDO SEGMENTOS ${i + 1} y ${i + 2}: ${groupedRoute}`);
                                    routes.push(groupedRoute);
                                    i += 2;
                                } else {
                                    // Procesar segmento individual
                                    const segmentDate = formatDateForRoute(segment.date);
                                    const route = `${getAirportDisplayName(segment.from)} ‚Üí ${getAirportDisplayName(segment.to)} (${segmentDate})`;
                                    console.log(`‚û°Ô∏è SEGMENTO INDIVIDUAL: ${route}`);
                                    routes.push(route);
                                    i++;
                                }
                            }
                            
                        } else {
                            console.log('\nüîÑ PROCESANDO COMO STOPOVER GEN√âRICO...');
                            
                            // L√≥gica original para otros casos
                            let i = 0;
                            
                            while (i < segments.length) {
                                const segment = segments[i];
                                console.log(`\nüîç Analizando segmento ${i + 1}: ${segment.from} ‚Üí ${segment.to}`);
                                
                                // Verificar si este segmento tiene "1 escala" y puede agruparse
                                const hasOneStop = segment.stops && segment.stops.toLowerCase().includes('1 escala');
                                const hasNextSegment = i < segments.length - 1;
                                const endsToPty = segment.to === 'PTY';
                                const nextStartsFromPty = hasNextSegment && segments[i + 1].from === 'PTY';
                                
                                console.log(`üîé AN√ÅLISIS DE AGRUPACI√ìN:`);
                                console.log(`   ‚îú‚îÄ Tiene "1 escala": ${hasOneStop}`);
                                console.log(`   ‚îú‚îÄ Termina en PTY: ${endsToPty}`);
                                console.log(`   ‚îî‚îÄ Siguiente empieza en PTY: ${nextStartsFromPty}`);
                                
                                // Agrupar si cumple todas las condiciones de "1 escala"
                                if (hasOneStop && hasNextSegment && endsToPty && nextStartsFromPty) {
                                    const nextSegment = segments[i + 1];
                                    
                                    // Respetar las fechas espec√≠ficas de cada segmento
                                    const firstSegmentDate = formatDateForRoute(segment.date);
                                    const secondSegmentDate = formatDateForRoute(nextSegment.date);
                                    
                                    // Si las fechas son iguales, mostrar una sola fecha
                                    // Si son diferentes, mostrar ambas fechas
                                    let dateDisplay;
                                    if (firstSegmentDate === secondSegmentDate) {
                                        dateDisplay = `(${firstSegmentDate})`;
                                    } else {
                                        dateDisplay = `(${firstSegmentDate}/${secondSegmentDate})`;
                                    }
                                    
                                    // Crear ruta agrupada con fechas espec√≠ficas
                                    const groupedRoute = `${getAirportDisplayName(segment.from)} ‚Üí ${getAirportDisplayName(nextSegment.to)} ${dateDisplay}`;
                                    console.log(`‚úÖ RUTA AGRUPADA: ${groupedRoute}`);
                                    routes.push(groupedRoute);
                                    i += 2;
                                } else {
                                    // Mostrar segmento individual con su fecha espec√≠fica
                                    if (segment.from && segment.to && segment.date) {
                                        const segmentDate = formatDateForRoute(segment.date);
                                        const route = `${getAirportDisplayName(segment.from)} ‚Üí ${getAirportDisplayName(segment.to)} (${segmentDate})`;
                                        console.log(`‚û°Ô∏è RUTA INDIVIDUAL: ${route}`);
                                        routes.push(route);
                                    } else {
                                        console.error(`‚ùå SEGMENTO ${i + 1} INCOMPLETO:`, segment);
                                    }
                                    i++;
                                }
                            }
                        }
                        
                        const result = routes.join('<br>');
                        console.log('\n=== üéØ RESULTADO FINAL DEL PROCESAMIENTO ===');
                        console.log('üìã Rutas procesadas:', routes);
                        console.log('üìä Total de rutas generadas:', routes.length);
                        console.log('üî§ HTML resultado:', result);
                        console.log('ÔøΩ Tipo de stopover aplicado:', isReturnStopover ? 'REGRESO' : isOutboundStopover ? 'IDA' : 'GEN√âRICO');
                        console.log('=== ‚úÖ FIN PROCESAMIENTO ===\n');
                        return result;
                    }
                    
                    // Solo usar datos de respaldo si NO hay segmentos de la API
                    console.error('üö® USANDO DATOS DE RESPALDO - NO HAY SEGMENTOS DE LA API');
                    console.log('üìã Par√°metros para respaldo:', {
                        city: city,
                        stopover: stopover,
                        searchDate: searchDate,
                        returnDate: returnDate
                    });
                    
                    const cityCode = city === 'Quito' ? 'UIO' : 
                                   city === 'Medell√≠n' ? 'MED' : 
                                   city === 'Cali' ? 'CLO' : 
                                   city === 'Cartagena' ? 'CTG' : 
                                   city === 'Bogot√°' ? 'BOG' : 
                                   city.substring(0, 3).toUpperCase();
                    
                    console.log(`üèôÔ∏è Ciudad "${city}" mapeada a c√≥digo: ${cityCode}`);
                    
                    const outboundDate = formatDateForRoute(searchDate);
                    const returnDateFormatted = formatDateForRoute(returnDate);
                    
                    console.log('üìÖ Fechas de respaldo formateadas:', { 
                        searchDate: searchDate,
                        outboundDate: outboundDate,
                        returnDate: returnDate,
                        returnDateFormatted: returnDateFormatted 
                    });
                    
                    // Mostrar itinerario simplificado agrupando escalas
                    const fallbackRoute = `LIM ‚Üí ${cityCode} (${outboundDate})<br>${cityCode} ‚Üí LIM (${returnDateFormatted})`;
                    console.log('üîÑ Ruta de respaldo generada:', fallbackRoute);
                    console.warn('‚ö†Ô∏è NOTA: Esta es una ruta simplificada sin datos reales de segmentos');
                    return fallbackRoute;
                }
                
                // INTENTAR OBTENER SEGMENTS DE M√öLTIPLES FUENTES
                let segments = data?.segments;
                
                // Si no hay segments en la ubicaci√≥n esperada, buscar en otras ubicaciones
                if (!segments || !Array.isArray(segments) || segments.length === 0) {
                    console.log('üîß BUSCANDO SEGMENTS EN UBICACIONES ALTERNATIVAS...');
                    
                    // Intentar diferentes ubicaciones donde podr√≠an estar los segments
                    segments = data?.flight_segments || 
                              data?.route || 
                              data?.itinerary || 
                              offer.segments ||
                              offer.route ||
                              offer.flight_segments;
                              
                    console.log('üîç Segments encontrados en ubicaci√≥n alternativa:', segments);
                }
                
                const routeDisplay = generateRouteDescription(segments, offer.city, offer.stopover, offer.searchDate, offer.returnDate);
                
                console.log(`\nüé® GENERANDO HTML PARA OFERTA #${index + 1}`);
                console.log('üõ´ RouteDisplay final generado:', routeDisplay);
                console.log('üìä N√∫mero de l√≠neas en la ruta:', (routeDisplay.match(/<br>/g) || []).length + 1);
                console.log('üéØ Expectativa: 3 l√≠neas para vuelos con escalas agrupadas correctamente');
                
                html += `
                    <div class="offer-card mb-3" data-combo-id="${offer.comboId}" data-city="${offer.city}">
                        <div class="card">
                            <div class="card-body">
                                <div class="row align-items-center">
                                    <div class="col-md-1">
                                        <div class="offer-rank">
                                            <span class="badge bg-primary">#${index + 1}</span>
                                        </div>
                                    </div>
                                    <div class="col-md-2">
                                        <h6 class="mb-1">${offer.city} (${getCityAirportCode(offer.city)})</h6>
                                        <small class="text-muted">Stopover de ${offer.stopover} en Panam√°</small>
                                    </div>
                                    <div class="col-md-3">
                                        <div class="date-info">
                                            <small class="text-muted">Salida:</small> ${formatDateDMY(offer.searchDate)}<br>
                                            <small class="text-muted">Regreso:</small> ${formatDateDMY(offer.returnDate)}
                                        </div>
                                    </div>
                                    <div class="col-md-4">
                                        <div class="route-info">
                                            <p class="mb-1"><strong>Ruta:</strong></p>
                                            <small style="line-height: 1.4; display: block; white-space: normal;">${routeDisplay}</small>
                                        </div>
                                    </div>
                                    <div class="col-md-2 text-end">
                                        <div class="price-info">
                                            <h5 class="text-primary mb-0">$${data.price}</h5>
                                            <small class="text-muted">USD</small>
                                        </div>
                                    </div>
                                </div>
                            </div>
                        </div>
                    </div>
                `;
            });
            
            html += '</div>';
            dateContents.innerHTML = html;
        }

        // Funci√≥n para filtrar ofertas por fecha
        function filterByDate(filterComboId) {
            // Actualizar botones activos
            const filterButtons = document.querySelectorAll('.btn-group button');
            
            // Remover clase active de todos los botones
            filterButtons.forEach(btn => {
                btn.classList.remove('active');
                btn.setAttribute('aria-pressed', 'false');
            });
            
            // Mostrar/ocultar ofertas con animaci√≥n
            const offers = document.querySelectorAll('.offer-card');
            let visibleCount = 0;
            
            offers.forEach(offer => {
                if (filterComboId === 'all' || offer.dataset.comboId === filterComboId) {
                    offer.style.display = 'block';
                    offer.style.animation = 'fadeIn 0.3s ease-in';
                    visibleCount++;
                } else {
                    offer.style.display = 'none';
                }
            });
            
            // Activar el bot√≥n correspondiente
            if (filterComboId === 'all') {
                filterButtons[0].classList.add('active');
                filterButtons[0].setAttribute('aria-pressed', 'true');
            } else {
                // Encontrar el bot√≥n correcto por el atributo data-combo-id
                filterButtons.forEach(btn => {
                    if (btn.getAttribute('data-combo-id') === filterComboId) {
                        btn.classList.add('active');
                        btn.setAttribute('aria-pressed', 'true');
                        
                        // Scroll autom√°tico en m√≥viles al bot√≥n activo
                        if (window.innerWidth <= 768) {
                            btn.scrollIntoView({ 
                                behavior: 'smooth', 
                                block: 'nearest',
                                inline: 'center'
                            });
                        }
                    }
                });
            }
            
            // Mostrar contador de resultados
            updateResultsCounter(visibleCount, filterComboId);
        }
        
        // Funci√≥n para actualizar contador de resultados
        function updateResultsCounter(count, filterType) {
            const existingCounter = document.querySelector('.results-counter');
            if (existingCounter) {
                existingCounter.remove();
            }
            
            const counter = document.createElement('div');
            counter.className = 'results-counter alert alert-info mt-2 mb-3';
            counter.innerHTML = `
                <i class="bi bi-info-circle"></i> 
                <strong>${count}</strong> ${count === 1 ? 'resultado encontrado' : 'resultados encontrados'}
                ${filterType !== 'all' ? ' para la combinaci√≥n seleccionada' : ''}
            `;
            
            const offersList = document.getElementById('offers-list');
            if (offersList && offersList.parentNode) {
                offersList.parentNode.insertBefore(counter, offersList);
            }
        }
        
        // Funci√≥n para formatear fecha en formato d√≠a/mes/a√±o
        function formatDateDMY(dateStr) {
            if (!dateStr) return '';
            
            // Si viene en formato YYYY-MM-DD
            const parts = dateStr.split('-');
            if (parts.length === 3) {
                const year = parts[0];
                const month = parts[1];
                const day = parts[2];
                return `${day}/${month}/${year}`;
            }
            
            // Si viene en formato DD/MM/YYYY ya est√° correcto
            if (dateStr.includes('/')) {
                return dateStr;
            }
            
            return dateStr; // Retornar como est√° si no se puede formatear
        }
        
        // Funci√≥n para formatear fecha compacta para m√≥viles (solo d√≠a/mes)
        function formatDateCompact(dateStr) {
            if (!dateStr) return '';
            
            // Si viene en formato YYYY-MM-DD
            const parts = dateStr.split('-');
            if (parts.length === 3) {
                const month = parts[1];
                const day = parts[2];
                return `${day}/${month}`;
            }
            
            // Si viene en formato DD/MM/YYYY extraer solo d√≠a/mes
            if (dateStr.includes('/')) {
                const parts = dateStr.split('/');
                if (parts.length >= 2) {
                    return `${parts[0]}/${parts[1]}`;
                }
            }
            
            return dateStr;
        }
        
        // Funci√≥n para inicializar funcionalidades m√≥viles
        function initializeMobileFeatures() {
            // Detectar si es dispositivo m√≥vil
            const isMobile = window.innerWidth <= 768;
            
            if (isMobile) {
                // Agregar soporte t√°ctil para los filtros
                const filterContainer = document.querySelector('.btn-group');
                if (filterContainer) {
                    addTouchSupport(filterContainer);
                }
                
                // Agregar indicador visual de scroll
                addScrollIndicator();
            }
            
            // Listener para cambios de orientaci√≥n
            window.addEventListener('orientationchange', function() {
                setTimeout(() => {
                    updateFilterLayout();
                }, 100);
            });
        }
        
        // Funci√≥n para agregar soporte t√°ctil
        function addTouchSupport(container) {
            let isScrolling = false;
            let startX = 0;
            let scrollLeft = 0;
            
            container.addEventListener('touchstart', function(e) {
                isScrolling = true;
                startX = e.touches[0].pageX - container.offsetLeft;
                scrollLeft = container.scrollLeft;
                container.style.cursor = 'grabbing';
            }, { passive: true });
            
            container.addEventListener('touchmove', function(e) {
                if (!isScrolling) return;
                e.preventDefault();
                const x = e.touches[0].pageX - container.offsetLeft;
                const walk = (x - startX) * 2;
                container.scrollLeft = scrollLeft - walk;
            });
            
            container.addEventListener('touchend', function() {
                isScrolling = false;
                container.style.cursor = 'grab';
            });
        }
        
        // Funci√≥n para agregar indicador de scroll
        function addScrollIndicator() {
            const filterContainer = document.querySelector('.btn-group');
            if (!filterContainer) return;
            
            const indicator = document.createElement('div');
            indicator.className = 'scroll-indicator';
            indicator.innerHTML = '<i class="bi bi-chevron-right"></i>';
            indicator.style.cssText = `
                position: absolute;
                right: 10px;
                top: 50%;
                transform: translateY(-50%);
                background: rgba(25, 118, 210, 0.8);
                color: white;
                border-radius: 50%;
                width: 30px;
                height: 30px;
                display: flex;
                align-items: center;
                justify-content: center;
                font-size: 12px;
                animation: pulse 2s infinite;
                z-index: 10;
            `;
            
            filterContainer.parentElement.style.position = 'relative';
            filterContainer.parentElement.appendChild(indicator);
            
            // Ocultar indicador despu√©s de primer scroll
            filterContainer.addEventListener('scroll', function() {
                indicator.style.display = 'none';
            }, { once: true });
        }
        
        // Funci√≥n para actualizar layout de filtros
        function updateFilterLayout() {
            const filterContainer = document.querySelector('.btn-group');
            if (!filterContainer) return;
            
            const isMobile = window.innerWidth <= 768;
            
            if (isMobile) {
                filterContainer.style.justifyContent = 'flex-start';
                filterContainer.style.flexWrap = 'nowrap';
            } else {
                filterContainer.style.justifyContent = 'center';
                filterContainer.style.flexWrap = 'wrap';
            }
        }
        
        // Inicializar funcionalidades m√≥viles cuando se cargan los datos
        function initializeApp() {
            fetchOffers();
            initializeMobileFeatures();
        }
        
        // üß™ FUNCI√ìN DE PRUEBA PARA VERIFICAR ROUTE GENERATION
        function testRouteGeneration() {
            console.log('\nüß™üß™üß™ INICIANDO PRUEBAS ESPEC√çFICAS DE ROUTE GENERATION üß™üß™üß™');
            
            // Funci√≥n auxiliar para formatear fecha
            function formatDateForRoute(dateStr) {
                if (!dateStr) return '';
                const parts = dateStr.split('-');
                if (parts.length === 3) {
                    return `${parts[2]}/${parts[1]}`;
                }
                return dateStr;
            }
            
            // Test Case 1: QUITO - Stopover de REGRESO en Panam√°
            console.log('\nüß™ TEST CASE 1: QUITO - Stopover de REGRESO');
            console.log('üìã Datos esperados:');
            console.log('   LIM ‚Üí UIO (11/02)');
            console.log('   UIO ‚Üí PTY (11/02)');  
            console.log('   PTY ‚Üí LIM (18/02)');
            
            // Simular l√≥gica de fallback para Quito
            const quitoCity = 'Quito';
            const quitoStopover = 'Stopover de regreso en Panam√°';
            const quitoSearchDate = '2026-02-11';
            const quitoReturnDate = '2026-02-18';
            
            const quitoCityCode = 'UIO';
            const quitoOutboundDate = formatDateForRoute(quitoSearchDate);
            const quitoReturnFormatted = formatDateForRoute(quitoReturnDate);
            const quitoIsReturnStopover = quitoStopover.toLowerCase().includes('regreso');
            
            let quitoRoute;
            if (quitoIsReturnStopover) {
                quitoRoute = `LIM ‚Üí ${quitoCityCode} (${quitoOutboundDate})<br>${quitoCityCode} ‚Üí PTY (${quitoOutboundDate})<br>PTY ‚Üí LIM (${quitoReturnFormatted})`;
            }
            
            console.log('üéØ RESULTADO QUITO:', quitoRoute);
            console.log('‚úÖ ¬øCoincide con lo esperado? Verificar manualmente');
            
            // Test Case 2: MEDELL√çN - Stopover de IDA en Panam√°  
            console.log('\nüß™ TEST CASE 2: MEDELL√çN - Stopover de IDA');
            console.log('üìã Datos esperados:');
            console.log('   LIM ‚Üí PTY (11/02)');
            console.log('   PTY ‚Üí MDE (18/02)');
            console.log('   MDE ‚Üí LIM (18/02)');
            
            // Simular l√≥gica de fallback para Medell√≠n
            const medellinCity = 'Medell√≠n';
            const medellinStopover = 'Stopover de ida en Panam√°';
            const medellinSearchDate = '2026-02-11';
            const medellinReturnDate = '2026-02-18';
            
            const medellinCityCode = 'MDE';
            const medellinOutboundDate = formatDateForRoute(medellinSearchDate);
            const medellinReturnFormatted = formatDateForRoute(medellinReturnDate);
            const medellinIsOutboundStopover = medellinStopover.toLowerCase().includes('ida');
            
            let medellinRoute;
            if (medellinIsOutboundStopover) {
                medellinRoute = `LIM ‚Üí PTY (${medellinOutboundDate})<br>PTY ‚Üí ${medellinCityCode} (${medellinReturnFormatted})<br>${medellinCityCode} ‚Üí LIM (${medellinReturnFormatted})`;
            }
            
            console.log('üéØ RESULTADO MEDELL√çN:', medellinRoute);
            console.log('‚úÖ ¬øCoincide con lo esperado? Verificar manualmente');
            
            // Test Case 3: Verificaci√≥n de c√≥digos de ciudad
            console.log('\nüß™ TEST CASE 3: VERIFICACI√ìN DE C√ìDIGOS DE CIUDAD');
            
            const cities = ['Quito', 'Medell√≠n', 'Cali', 'Cartagena', 'Bogot√°'];
            const expectedCodes = ['UIO', 'MDE', 'CLO', 'CTG', 'BOG'];
            
            cities.forEach((city, index) => {
                const cityCode = city === 'Quito' ? 'UIO' : 
                               city === 'Medell√≠n' ? 'MDE' : 
                               city === 'Cali' ? 'CLO' : 
                               city === 'Cartagena' ? 'CTG' : 
                               city === 'Bogot√°' ? 'BOG' : 
                               city.substring(0, 3).toUpperCase();
                
                console.log(`   ${city} ‚Üí ${cityCode} (esperado: ${expectedCodes[index]})`);
                console.log(`   ‚úÖ ${cityCode === expectedCodes[index] ? 'CORRECTO' : 'ERROR'}`);
            });
            
            console.log('\nüß™üß™üß™ FIN DE PRUEBAS ESPEC√çFICAS üß™üß™üß™');
        }
        
        // Agregar bot√≥n cuando se carga la p√°gina
        document.addEventListener('DOMContentLoaded', function() {
            
            // Tambi√©n agregar una funci√≥n global para pruebas manuales
            window.debugRouteGeneration = testRouteGeneration;
            window.testRealData = function() {
                console.log('üîç Iniciando b√∫squeda real para obtener datos de la API...');
                fetchOffers();
            };
            
            console.log('üõ†Ô∏è FUNCIONES DE DEBUG DISPONIBLES:');
            console.log('   - window.debugRouteGeneration() - Prueba con datos simulados');
            console.log('   - window.testRealData() - Ejecuta b√∫squeda real de ofertas');
            
            // Ejecutar pruebas autom√°ticamente al cargar
            setTimeout(() => {
                console.log('\nü§ñ EJECUTANDO PRUEBAS AUTOM√ÅTICAS AL CARGAR LA P√ÅGINA...');
                testRouteGeneration();
            }, 1000);
        });
    </script>
</body>
</html>